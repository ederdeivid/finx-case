
## ğŸ§± DecisÃµes TÃ©cnicas e Arquiteturais

### ConfiguraÃ§Ã£o Inicial

Inicialmente configurei os critÃ©rios bÃ¡sicos para o app: definiÃ§Ã£o das versÃµes de **Node**, **npm** e suporte a **nvm**, garantindo que todos os desenvolvedores trabalhem com o mesmo ambiente.

### Por que Nuxt?

A escolha do **Nuxt** foi baseada em dois motivos principais:

1. **Convention over Configuration:** Ã‰ essencialmente Vue, porÃ©m com padrÃµes jÃ¡ definidos (rotas, estrutura de pastas, etc.), reduzindo a necessidade de configuraÃ§Ãµes manuais e acelerando o desenvolvimento.

2. **SSR e Performance:** Com base nos requisitos do teste, onde otimizaÃ§Ã£o e velocidade sÃ£o pontos importantes, o **Server-Side Rendering (SSR)** resolve boa parte dos problemas de lentidÃ£o, jÃ¡ que o processamento Ã© feito do lado do servidor. Isso tambÃ©m permite trabalhar com **BFF (Backend for Frontend)** e **cache no front-end** utilizando o **Nuxt Nitro**.

### Estrutura por DomÃ­nios com Nuxt Layers

Para estruturar o projeto por **domÃ­nios** ao invÃ©s da estrutura de pastas padrÃ£o, optei por utilizar o **Nuxt Layers**. Esta abordagem pode ser facilmente implementada tanto em aplicaÃ§Ãµes Nuxt quanto em aplicaÃ§Ãµes Vue puras.

**MotivaÃ§Ã£o:** Quando a aplicaÃ§Ã£o cresce, pastas genÃ©ricas como `components/`, `stores/` e `services/` acabam acumulando muitos arquivos soltos. Com Layers, o projeto fica **organizado por domÃ­nio**, facilitando a manutenÃ§Ã£o e escalabilidade.

```
app/
â”œâ”€â”€ layers/
â”‚   â””â”€â”€ consultas/          # DomÃ­nio de consultas
â”‚       â”œâ”€â”€ components/
â”‚       â”œâ”€â”€ composables/
â”‚       â””â”€â”€ pages/
â”œâ”€â”€ components/             # Componentes compartilhados
â”œâ”€â”€ composables/            # LÃ³gica reutilizÃ¡vel
â””â”€â”€ types/                  # Interfaces TypeScript
```

### BFF e ManipulaÃ§Ã£o de Dados

Na parte de busca pelas informaÃ§Ãµes, eu poderia simplesmente fazer um `filter` com RegExp no front buscando dados do JSON, mas isso quebraria a finalidade do **BFF**.

**Abordagem escolhida:** O front-end **nÃ£o faz manipulaÃ§Ã£o e tratamento de dados**, apenas chama a request (seja para o Mock ou para uma API externa). Dessa forma:

- O servidor processa e filtra os dados
- Mesmo com MUITOS dados na request, o front-end nÃ£o sente sobrecarga
- A separaÃ§Ã£o de responsabilidades fica clara

### Reatividade com defineModel

Na reatividade dos componentes com props para componentes filhos, ao invÃ©s de usar o padrÃ£o com `emit` e `update:algumaCoisa`, optei por uma abordagem mais moderna utilizando o **`defineModel`**.

Por trÃ¡s dos panos faz a mesma coisa, porÃ©m de maneira **muito menos verbosa e mais intuitiva**:

```typescript
// Antes (verboso)
const props = defineProps<{ modelValue: string }>()
const emit = defineEmits<{ 'update:modelValue': [value: string] }>()

// Depois (com defineModel)
const model = defineModel<string>({ required: true })
```

### Nomenclatura de VariÃ¡veis

Optei por manter o **nome das regras de domÃ­nio em portuguÃªs** (ex: `medico`, `paciente`, `convenio`, `dataNascimento`), enquanto variÃ¡veis de cÃ³digo e lÃ³gica permanecem em inglÃªs (ex: `filteredRequests`, `currentPage`).

Isso facilita a comunicaÃ§Ã£o com a equipe de negÃ³cio e mantÃ©m a consistÃªncia com os modelos de dados.

---

## ğŸ› ï¸ Qualidade de CÃ³digo

Para garantir consistÃªncia e qualidade no desenvolvimento, este projeto utiliza as seguintes ferramentas:

### âœ… Conventional Commits

- Padroniza mensagens de commit com base em [conventionalcommits.org](https://www.conventionalcommits.org/)
- Facilita a geraÃ§Ã£o automÃ¡tica de changelogs e melhora a rastreabilidade de mudanÃ§as
- Commits bem descritos fazem parte dos critÃ©rios de avaliaÃ§Ã£o

### ğŸ¶ Husky

- Executa hooks de Git para prevenir erros antes que o cÃ³digo seja commitado
- Garante que o commit **nÃ£o suba com problemas** de lint ou testes

### ğŸ¯ lint-staged

- Executa o ESLint apenas nos arquivos que foram modificados e estÃ£o staged
- Otimiza o tempo de validaÃ§Ã£o e evita que arquivos nÃ£o alterados sejam reprocessados

---

## ğŸ“ PrincÃ­pios e PadrÃµes Aplicados

### SOLID - Single Responsibility Principle (SRP)

Cada mÃ³dulo, composable ou componente tem **uma Ãºnica responsabilidade**:

| Composable | Responsabilidade |
|------------|------------------|
| `usePatientAge` | Apenas cÃ¡lculo de idade |
| `useDateFormat` | Apenas formataÃ§Ã£o de datas |
| `useConsultasApi` | Apenas comunicaÃ§Ã£o com a API de consultas |

Isso facilita testes, manutenÃ§Ã£o e reutilizaÃ§Ã£o do cÃ³digo.

### Clean Code

- **Nomes significativos:** VariÃ¡veis e funÃ§Ãµes com nomes que descrevem claramente seu propÃ³sito
- **FunÃ§Ãµes pequenas:** Cada funÃ§Ã£o faz apenas uma coisa
- **CÃ³digo auto-documentado:** O cÃ³digo Ã© legÃ­vel sem necessidade de comentÃ¡rios excessivos

### ProgramaÃ§Ã£o Estruturada

Onde foi possÃ­vel, apliquei o conceito de **programaÃ§Ã£o estruturada**, onde o cÃ³digo segue uma **linha racional**, como se fosse a leitura de um livro.

Isso facilita entender o que vem depois, sem saltos imprevisÃ­veis no cÃ³digo.

---

## ğŸ“¦ Stack TecnolÃ³gica

- **Framework:** Nuxt 4 com Vue 3
- **Linguagem:** TypeScript (strict mode)
- **EstilizaÃ§Ã£o:** Tailwind CSS v4
- **Estado:** Vue Composition API com Composables
- **Testes:** Vitest
- **Linting:** ESLint
- **Gerenciamento de estado:** AplicaÃ§Ã£o simples, nÃ£o houve necessidade
